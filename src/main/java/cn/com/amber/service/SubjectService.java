package cn.com.amber.service;import cn.com.amber.api.dto.req.QuerySubjectReq;import cn.com.amber.api.dto.response.SubjectDTO;import cn.com.amber.commons.untils.StringUtil;import cn.com.amber.entity.Subject;import cn.com.amber.entity.enums.AccountingElementEnum;import cn.com.amber.infrastructure.api.enums.ResponseCode;import cn.com.amber.infrastructure.exception.BusinessException;import cn.com.amber.mapper.SubjectMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.*;import java.util.stream.Collectors;/** * 科目服务 * * @author yangying * @version 1.0 * @since 2022/9/21 **/@Servicepublic class SubjectService {    private final SubjectMapper subjectMapper;    @Autowired    public SubjectService(SubjectMapper subjectMapper) {        this.subjectMapper = subjectMapper;    }    /**     * 根据科目编号列表查询科目信息     * @param subjectNos 科目编号列表     * @return 科目列表     */    public List<Subject> querySubjects(List<String> subjectNos) {        return subjectMapper.selectBySubjectNoList(subjectNos);    }    /**     * 查询科目信息，会按照科目级别层次组织     * @param querySubjectReq 查询科目请求     * @return 科目列表，按照科目级别组织层次，{@link SubjectDTO}     */    public List<SubjectDTO> querySubjectHierarchy(QuerySubjectReq querySubjectReq) {        AccountingElementEnum elementType = AccountingElementEnum.getValue(querySubjectReq.getElement());        if (StringUtil.isBlankString(querySubjectReq.getSubjectNo()) && elementType == AccountingElementEnum.UN_KNOW) {            throw BusinessException.create(ResponseCode.ILLEGAL_ARGUMENT, "科目编号和会计要素必须选择其一");        }        String subjectNo = querySubjectReq.getSubjectNo();        if (queryOnlyByElement(subjectNo, elementType)) {            return buildSubjectHierarchyByElement(elementType);        }        Subject root;        if (queryOnlyBySubjectNo(subjectNo, elementType)) {            root = queryBySubjectNo(subjectNo);        } else {            root = queryBySubjectNoAndElement(subjectNo, elementType);        }        return buildSubjectHierarchyByRoot(root);    }    private boolean queryOnlyByElement(String subjectNo, AccountingElementEnum accountingElementEnum) {        return StringUtil.isBlankString(subjectNo) && accountingElementEnum != AccountingElementEnum.UN_KNOW;    }    private List<SubjectDTO> buildSubjectHierarchyByElement(AccountingElementEnum elementType) {        List<Subject> allSubject = subjectMapper.selectByElement(elementType.getCode());        List<Subject> sortedByLevel = allSubject.stream().sorted(Comparator.comparing(Subject::getLevel))                .collect(Collectors.toList());        return buildSubjectTree(sortedByLevel);    }    /**     * @param sortedByLevel 按照level排序好，科目level值越小，层级越高。     * @return list     */    private List<SubjectDTO> buildSubjectTree(List<Subject> sortedByLevel) {        Map<Long, SubjectDTO> nodeMap = new HashMap<>();        List<SubjectDTO> roots = new ArrayList<>();        int startLevel = sortedByLevel.get(0).getLevel();        for (Subject subject : sortedByLevel) {            SubjectDTO node = SubjectDTO.builder().subjectName(subject.getSubjectName()).subjectNo(subject.getSubjectNo())                    .direction(subject.getDirection()).element(subject.getElement()).level(subject.getLevel()).build();            nodeMap.put(subject.getId(), node);            if (subject.getParentId() != null && subject.getLevel() > startLevel) {                SubjectDTO parent = nodeMap.get(subject.getParentId());                if (parent.getChildren() == null) {                    parent.setChildren(new ArrayList<>());                }                parent.getChildren().add(node);                node.setParentSubjectNo(parent.getSubjectNo());            } else {                roots.add(node);            }        }        return roots;    }    private boolean queryOnlyBySubjectNo(String subjectNo, AccountingElementEnum accountingElementEnum) {        return !StringUtil.isBlankString(subjectNo) && accountingElementEnum == AccountingElementEnum.UN_KNOW;    }    /**     * 根据科目号查询科目     *     * @param subjectNo     * @return Subject     * @throws BusinessException - if not found     */    public Subject queryBySubjectNo(String subjectNo) {        Subject subject = subjectMapper.selectBySubjectNo(subjectNo);        validateExist(subject, subjectNo);        return subject;    }    public Subject queryBySubjectNoAndElement(String subjectNo, AccountingElementEnum element) {        Subject subject = subjectMapper.selectBySubjectNoAndElement(subjectNo, element.getCode());        validateExist(subject, subjectNo, element);        return subject;    }    private void validateExist(Subject subject, Object... args) {        if (subject == null) {            throw BusinessException.create(ResponseCode.SUBJECT_NOT_FOUND, args);        }    }    private List<SubjectDTO> buildSubjectHierarchyByRoot(Subject root) {        List<Subject> sorted = new ArrayList<>();        Queue<Subject> cur = new LinkedList<>();        Queue<Subject> next;        cur.add(root);        while (!cur.isEmpty()) {            next = new LinkedList<>();            while (!cur.isEmpty()) {                Subject node = cur.poll();                sorted.add(node);                List<Subject> children = subjectMapper.selectByParentId(node.getId());                next.addAll(children);            }            cur.addAll(next);        }        return buildSubjectTree(sorted);    }}